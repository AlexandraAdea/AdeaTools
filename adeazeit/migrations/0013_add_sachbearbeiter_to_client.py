# Generated by Django 5.1.2 on 2025-11-26 09:23

from django.db import migrations, transaction

IDX_DROP = "adeazeit_ab_mitarbe_ada11c_idx"
IDX_OLD = "adeazeit_abs_employe_123456_idx"
IDX_NEW = "adeazeit_ab_employe_c4ea6a_idx"


def _rename_index_forward(apps, schema_editor):
    """
    DB-sicherer Index-Rename mit transaction.atomic() als Savepoint.
    Falls ein SQL-Befehl fehlschlägt, wird nur der Savepoint zurückgerollt –
    die Haupttransaktion der Migration bleibt sauber (kein InFailedSqlTransaction).
    """
    vendor = schema_editor.connection.vendor
    if vendor == "postgresql":
        try:
            with transaction.atomic(using=schema_editor.connection.alias):
                with schema_editor.connection.cursor() as cursor:
                    cursor.execute(f"SELECT to_regclass('{IDX_OLD}');")
                    old_exists = cursor.fetchone()[0] is not None

                    cursor.execute(f"SELECT to_regclass('{IDX_NEW}');")
                    new_exists = cursor.fetchone()[0] is not None

                    if old_exists and not new_exists:
                        cursor.execute(
                            f'ALTER INDEX "{IDX_OLD}" RENAME TO "{IDX_NEW}";'
                        )
        except Exception:
            # Savepoint wurde zurückgerollt, Haupttransaktion bleibt sauber
            pass

    elif vendor == "sqlite":
        # SQLite: Index-Rename ist nicht kritisch für App-Logik, best-effort
        try:
            with schema_editor.connection.cursor() as cursor:
                cursor.execute(f'DROP INDEX IF EXISTS "{IDX_OLD}";')
        except Exception:
            pass


def _rename_index_backward(apps, schema_editor):
    """Reverse-Operation (best-effort)."""
    vendor = schema_editor.connection.vendor
    if vendor == "postgresql":
        try:
            with transaction.atomic(using=schema_editor.connection.alias):
                with schema_editor.connection.cursor() as cursor:
                    cursor.execute(f"SELECT to_regclass('{IDX_NEW}');")
                    new_exists = cursor.fetchone()[0] is not None

                    cursor.execute(f"SELECT to_regclass('{IDX_OLD}');")
                    old_exists = cursor.fetchone()[0] is not None

                    if new_exists and not old_exists:
                        cursor.execute(
                            f'ALTER INDEX "{IDX_NEW}" RENAME TO "{IDX_OLD}";'
                        )
        except Exception:
            pass


class Migration(migrations.Migration):

    dependencies = [
        ("adeazeit", "0012_task_remove_absence_adeazeit_ab_mitarbe_ada11c_idx_and_more"),
    ]

    operations = [
        # 1) RemoveIndex: DB-idempotent mit IF EXISTS, State bereinigen
        migrations.RunSQL(
            sql=f'DROP INDEX IF EXISTS "{IDX_DROP}";',
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.RemoveIndex(
                    model_name="absence",
                    name=IDX_DROP,
                ),
            ],
        ),

        # 2) RenameIndex: DB-sicher mit Savepoint (transaction.atomic)
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(_rename_index_forward, _rename_index_backward),
            ],
            state_operations=[
                migrations.RenameIndex(
                    model_name="absence",
                    old_name=IDX_OLD,
                    new_name=IDX_NEW,
                ),
            ],
        ),
    ]
